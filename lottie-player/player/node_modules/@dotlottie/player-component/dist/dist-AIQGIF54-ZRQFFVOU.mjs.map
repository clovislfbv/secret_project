{"version":3,"sources":["../../../node_modules/.pnpm/@humanwhocodes+momoa@2.0.3/node_modules/@humanwhocodes/momoa/api.js"],"names":["offset","c","oe","Q","Na","xt","Ba","Fa","bt","kt","Ga","Ka","Ua","$a","Ha","wt","qa","Za","Wa","Xa","Tt","Ja","Ya","Qa","er","tr","ar","rr","nr","ir","or","sr","lr","fr","cr","ur","pr","mr","yr","dr","hr","O","vt","gr","fe","Pt","se","Ct","De","ct","e","ut","Sr","t","n","xr","i","br","kr","wr","Tr","vr","ke","ze","we","B","pt","Ot","Pr","Cr","xe","mt","yt","dt","Vt","ht","Or","Vr","H","be","Fe","Ar","gt","Er","At","le","_r","Z","q","Lr","Ir","Dr","zr","jr","F","Rr","Mr","Te","Nr","Br","Fr","ee","Gr","Kr","Pe","Ur","$r","Hr","te","qr","Zr","Wr","Xr","Jr","Yr","Ne","Me","o","It","l","zt","m","d","g","_t","je","Ce","Be","Qr","en","yn","ve","dn","kn","St","ce","tn","xn","Ke","Pn","an","Dt","rn","bn","Lt","Et","nn","Re","jt","b","P","j","z","E","Cn","un","ln","cn","On","Vn","hn","on","Tn","wn","Rt","sn","En","fn","pn","mn","gn","Sn","Ge","vn","_n","An","Zt","G","Ln","In","Dn","zn","jn","Rn","Gt","Kt","Ut","Mt","Mn","He","newLine","locate","line","readKeyword","value","column","text","unexpected","next","QUOTE$1","escapeToChar","qe","unexpectedEOF","isDigit","Bt","Ft","Nn","Bn","W","readComment","Fn","Gn","Kn","Un","$t","u","y","x","v","_","C"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.value !== \"}\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.value === \",\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.value !== \"]\") {\n\n            do {\n\n              // add the value into the array\n              elements.push(parseValue(token));\n\n              token = next();\n              \n              if (token.value === \",\") {\n                  token = next();\n              } else {\n                  break;\n              }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n"]}